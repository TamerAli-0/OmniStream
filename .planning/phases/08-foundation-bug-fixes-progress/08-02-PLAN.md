---
phase: 08-foundation-bug-fixes-progress
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/main/java/com/omnistream/ui/library/LibraryViewModel.kt
  - app/src/main/java/com/omnistream/ui/library/LibraryScreen.kt
  - app/src/main/java/com/omnistream/ui/search/SearchViewModel.kt
autonomous: true

must_haves:
  truths:
    - "User opens Library screen and sees locally favorited items from Room database"
    - "Library screen works offline (no cloud dependency for display)"
    - "User types rapidly in search bar and results load cleanly without duplicates or stale data"
    - "Search debounce waits 400ms after last keystroke before firing"
  artifacts:
    - path: "app/src/main/java/com/omnistream/ui/library/LibraryViewModel.kt"
      provides: "Library ViewModel reading from Room FavoriteDao"
      contains: "favoriteDao"
    - path: "app/src/main/java/com/omnistream/ui/library/LibraryScreen.kt"
      provides: "Library screen rendering FavoriteEntity data"
      contains: "FavoriteEntity"
    - path: "app/src/main/java/com/omnistream/ui/search/SearchViewModel.kt"
      provides: "Search with Flow debounce pipeline"
      contains: "debounce"
  key_links:
    - from: "LibraryViewModel.kt"
      to: "FavoriteDao"
      via: "Hilt injection + Flow collection"
      pattern: "favoriteDao\\.getAllFavorites"
    - from: "LibraryScreen.kt"
      to: "FavoriteEntity"
      via: "UI rendering favorites list"
      pattern: "FavoriteEntity"
    - from: "SearchViewModel.kt"
      to: "SourceManager"
      via: "flatMapLatest Flow pipeline"
      pattern: "flatMapLatest"
---

<objective>
Fix BUG-01 (Library shows cloud data instead of local Room favorites) and BUG-02 (search race condition with rapid typing).

Purpose: These are two independent bug fixes that make the existing app stable. Library must work offline by reading from Room. Search must handle rapid typing without duplicate/stale results.

Output: Updated LibraryViewModel.kt, LibraryScreen.kt, and SearchViewModel.kt.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-foundation-bug-fixes-progress/08-CONTEXT.md
@.planning/phases/08-foundation-bug-fixes-progress/08-RESEARCH.md

Key source files:
@app/src/main/java/com/omnistream/ui/library/LibraryViewModel.kt
@app/src/main/java/com/omnistream/ui/library/LibraryScreen.kt
@app/src/main/java/com/omnistream/ui/search/SearchViewModel.kt
@app/src/main/java/com/omnistream/data/local/FavoriteEntity.kt
@app/src/main/java/com/omnistream/data/local/FavoriteDao.kt
@app/src/main/java/com/omnistream/data/remote/dto/SyncDtos.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Library screen to read from Room FavoriteDao instead of cloud SyncRepository (BUG-01)</name>
  <files>
    app/src/main/java/com/omnistream/ui/library/LibraryViewModel.kt
    app/src/main/java/com/omnistream/ui/library/LibraryScreen.kt
  </files>
  <action>
    **LibraryViewModel.kt -- rewrite to use Room FavoriteDao:**

    The current LibraryViewModel injects only `SyncRepository` and calls `syncRepository.fetchSyncData()` which hits a cloud API. This fails offline and is the source of BUG-01.

    Replace with:
    - Inject `FavoriteDao` (already provided by Hilt in AppModule) AND keep `SyncRepository` for dual-write (though dual-write logic is in the detail screens where favorites are added, not in the Library ViewModel -- the ViewModel just reads).
    - Actually, the ViewModel only needs `FavoriteDao` for reading. Remove `SyncRepository` from the constructor entirely -- it's not needed for the Library display.
    - Simplify `LibraryUiState`: Since Room FavoriteEntity does NOT have `category`, `progress`, `unreadCount`, or `lastChapter` fields (those were cloud-only LibraryEntryDto fields), the Library screen simplifies to just showing all favorites as a flat list. Change:
      ```kotlin
      data class LibraryUiState(
          val isLoading: Boolean = false,
          val error: String? = null,
          val favorites: List<FavoriteEntity> = emptyList()
      )
      ```
      Remove the `reading`, `planToRead`, `completed`, `onHold` lists -- FavoriteEntity has no category field, so all items are just "favorites".
    - In `init`, collect `favoriteDao.getAllFavorites()` as a Flow:
      ```kotlin
      init {
          viewModelScope.launch {
              favoriteDao.getAllFavorites().collect { favorites ->
                  _uiState.value = LibraryUiState(
                      isLoading = false,
                      favorites = favorites
                  )
              }
          }
      }
      ```
    - Remove the `loadLibrary()` function (no longer needed -- Flow auto-updates).
    - Import `com.omnistream.data.local.FavoriteDao` and `com.omnistream.data.local.FavoriteEntity`. Remove import for `SyncRepository` and `LibraryEntryDto`.

    **LibraryScreen.kt -- adapt to FavoriteEntity:**

    The current screen uses `LibraryEntryDto` with fields like `progress`, `unreadCount`, `lastChapter`. FavoriteEntity only has: `id`, `contentId`, `sourceId`, `contentType`, `title`, `coverUrl`, `addedAt`.

    Changes needed:
    1. Remove the import for `LibraryEntryDto`. Add import for `FavoriteEntity`.
    2. Remove the category tabs (HorizontalPager, TabRow, pagerState, categoryNames, categoryData). Replace with a single grid of all favorites.
    3. The `LibraryGridCard` composable: remove `progress` and `unreadCount` params. Keep `title`, `imageUrl`, `onClick`. Remove the `LinearProgressIndicator` and the unread badge.
    4. The `LibraryListCard` composable: remove `lastRead` and `unreadCount` params. Keep `title`, `source` (map from `entry.sourceId`), `imageUrl`, `onClick`. Remove the Badge.
    5. In the main content area, replace the HorizontalPager with a single `LazyVerticalGrid` that iterates over `uiState.favorites` (which are now `FavoriteEntity` objects).
    6. For item click navigation, use `entry.contentId`, `entry.sourceId`, and `entry.contentType` from FavoriteEntity (same field names as LibraryEntryDto, so navigation logic stays the same).
    7. Remove the "Refresh" IconButton from the TopAppBar (or keep it but remove `viewModel.loadLibrary()` call -- Flow auto-refreshes). The Refresh button can stay for user comfort, but make it a no-op or just log.
    8. The Retry button in error state can also be removed since Flow-based observation doesn't have retry semantics -- but keep error state handling in case of edge cases.
    9. Keep the grid/list toggle (`isGridView`) and the empty state.

    IMPORTANT: Do NOT remove `SyncRepository` from AppModule -- other parts of the app may use it. Only remove it from LibraryViewModel's constructor.
  </action>
  <verify>Run `cd C:/Users/black/AndroidStudioProjects/omnistream && ./gradlew compileDebugKotlin 2>&1 | tail -30`. No compilation errors in LibraryViewModel or LibraryScreen. Specifically no "Unresolved reference: LibraryEntryDto" or "Unresolved reference: SyncRepository" in LibraryViewModel.</verify>
  <done>LibraryViewModel reads from Room FavoriteDao via Flow (not cloud SyncRepository). LibraryScreen renders FavoriteEntity objects. No category tabs (since FavoriteEntity has no category). Library works offline. BUG-01 fixed.</done>
</task>

<task type="auto">
  <name>Task 2: Fix search race condition with Flow debounce pipeline (BUG-02)</name>
  <files>
    app/src/main/java/com/omnistream/ui/search/SearchViewModel.kt
  </files>
  <action>
    **SearchViewModel.kt -- replace manual Job debounce with Flow pipeline:**

    The current implementation uses `searchJob?.cancel()` + `delay(300)` which causes race conditions. Replace with `Flow.debounce(400).distinctUntilChanged().flatMapLatest{}`.

    Changes:
    1. Add a `private val _searchQuery = MutableStateFlow("")` field.
    2. In `init {}`, set up the Flow pipeline:
       ```kotlin
       init {
           viewModelScope.launch {
               _searchQuery
                   .debounce(400)
                   .distinctUntilChanged()
                   .flatMapLatest { query ->
                       if (query.isBlank()) {
                           flowOf(SearchUiState())
                       } else {
                           flow {
                               emit(_uiState.value.copy(isLoading = true, error = null, query = query))
                               try {
                                   val results = performSearch(query)
                                   emit(SearchUiState(
                                       isLoading = false,
                                       results = results,
                                       query = query,
                                       error = if (results.isEmpty()) "No results found" else null,
                                       selectedFilter = _uiState.value.selectedFilter
                                   ))
                               } catch (e: Exception) {
                                   emit(_uiState.value.copy(
                                       isLoading = false,
                                       error = e.message ?: "Search failed"
                                   ))
                               }
                           }
                       }
                   }
                   .collect { state -> _uiState.value = state }
           }
       }
       ```
    3. Replace the `fun search(query: String)` method with `fun onQueryChanged(query: String)` that simply sets `_searchQuery.value = query`. Keep the method name `search` if SearchScreen.kt calls it by that name -- check the SearchScreen to see what it calls. If it calls `viewModel.search(query)`, keep the name `search` but change the body to `_searchQuery.value = query`.
    4. Remove the `private var searchJob: Job?` field.
    5. Move the `performSearch` method body (parallel source search logic) into a new private suspend function. Keep the existing parallel search logic (videoSources.map { async { ... } } + mangaSources.map { async { ... } }) but move it to return `List<SearchResult>` instead of updating UI state directly.
    6. Remove the `delay(300)` and `searchJob?.cancel()` pattern entirely.
    7. Add imports: `kotlinx.coroutines.flow.debounce`, `kotlinx.coroutines.flow.distinctUntilChanged`, `kotlinx.coroutines.flow.flatMapLatest`, `kotlinx.coroutines.flow.flow`, `kotlinx.coroutines.flow.flowOf`.
    8. Add `@OptIn(kotlinx.coroutines.FlowPreview::class, kotlinx.coroutines.ExperimentalCoroutinesApi::class)` to the class since `debounce` is FlowPreview and `flatMapLatest` is ExperimentalCoroutinesApi.
    9. Keep `setFilter()`, `getFilteredResults()`, `SearchUiState`, `SearchResult`, and `SearchFilter` exactly as they are.

    IMPORTANT: The `performSearch` function must use `coroutineScope { }` to create async tasks (NOT `viewModelScope.async`) because it runs inside a flow that may be cancelled by flatMapLatest. Using `viewModelScope.async` would leak coroutines. Use `coroutineScope { listOf(async { ... }).awaitAll() }` pattern instead.
  </action>
  <verify>Run `cd C:/Users/black/AndroidStudioProjects/omnistream && ./gradlew compileDebugKotlin 2>&1 | tail -30`. No compilation errors in SearchViewModel. Verify no references to `searchJob` or `delay(300)` remain. Check: `grep -n "searchJob\|delay(300)" app/src/main/java/com/omnistream/ui/search/SearchViewModel.kt` should return nothing.</verify>
  <done>SearchViewModel uses Flow.debounce(400).distinctUntilChanged().flatMapLatest{} pipeline. No manual Job cancellation. No delay(). Race condition eliminated. Previous search results are automatically cancelled when user types again. BUG-02 fixed.</done>
</task>

</tasks>

<verification>
1. `./gradlew compileDebugKotlin` passes
2. LibraryViewModel constructor takes `FavoriteDao`, not `SyncRepository`
3. LibraryScreen renders `FavoriteEntity` objects, not `LibraryEntryDto`
4. SearchViewModel has `_searchQuery: MutableStateFlow<String>` and `debounce(400)` in init block
5. No `searchJob` variable or `delay(300)` in SearchViewModel
6. `performSearch` uses `coroutineScope { }` not `viewModelScope.async { }`
</verification>

<success_criteria>
- Library screen displays favorites from local Room database (not cloud API)
- Library screen works without network connectivity
- Search handles rapid typing via Flow debounce -- no duplicate results, no stale data
- Search waits 400ms after last keystroke, cancels in-flight requests on new input
- Both fixes compile cleanly and don't break other parts of the app
</success_criteria>

<output>
After completion, create `.planning/phases/08-foundation-bug-fixes-progress/08-02-SUMMARY.md`
</output>
